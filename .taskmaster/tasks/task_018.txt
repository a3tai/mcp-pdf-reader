# Task ID: 18
# Title: Create Automated Release Preparation System
# Status: done
# Dependencies: 16, 17
# Priority: medium
# Description: Design and implement a comprehensive release automation system that handles version tagging, changelog generation from commit history, release note compilation, and orchestrates the complete release process including pre-release checks and post-release notifications.
# Details:
Implement a complete release preparation system with multiple components:

```go
// internal/release/manager.go
package release

type ReleaseManager struct {
    git         *GitClient
    changelog   *ChangelogGenerator
    versioning  *VersionManager
    validator   *ReleaseValidator
    notifier    *ReleaseNotifier
}

func (rm *ReleaseManager) PrepareRelease(version string, releaseType ReleaseType) (*Release, error) {
    // 1. Validate version format
    if err := rm.versioning.ValidateVersion(version); err != nil {
        return nil, fmt.Errorf("invalid version: %w", err)
    }
    
    // 2. Run pre-release checks
    if err := rm.validator.RunPreReleaseChecks(); err != nil {
        return nil, fmt.Errorf("pre-release checks failed: %w", err)
    }
    
    // 3. Generate changelog
    changelog, err := rm.changelog.Generate(version)
    if err != nil {
        return nil, fmt.Errorf("changelog generation failed: %w", err)
    }
    
    // 4. Create release object
    release := &Release{
        Version:     version,
        Type:        releaseType,
        Changelog:   changelog,
        CreatedAt:   time.Now(),
    }
    
    return release, nil
}

// internal/release/changelog.go
type ChangelogGenerator struct {
    git    *GitClient
    parser *CommitParser
}

func (cg *ChangelogGenerator) Generate(targetVersion string) (*Changelog, error) {
    // Get previous version tag
    prevTag, err := cg.git.GetPreviousTag(targetVersion)
    if err != nil {
        prevTag = "" // First release
    }
    
    // Get commits between tags
    commits, err := cg.git.GetCommitsBetween(prevTag, "HEAD")
    if err != nil {
        return nil, err
    }
    
    // Parse and categorize commits
    changelog := &Changelog{
        Version:  targetVersion,
        Date:     time.Now(),
        Sections: make(map[string][]ChangeEntry),
    }
    
    for _, commit := range commits {
        entry := cg.parser.ParseCommit(commit)
        if entry != nil {
            changelog.AddEntry(entry)
        }
    }
    
    return changelog, nil
}

// internal/release/version.go
type VersionManager struct {
    strategy VersionStrategy
}

func (vm *VersionManager) NextVersion(currentVersion string, bumpType BumpType) (string, error) {
    current, err := semver.Parse(currentVersion)
    if err != nil {
        return "", err
    }
    
    switch bumpType {
    case BumpMajor:
        return fmt.Sprintf("v%d.0.0", current.Major+1), nil
    case BumpMinor:
        return fmt.Sprintf("v%d.%d.0", current.Major, current.Minor+1), nil
    case BumpPatch:
        return fmt.Sprintf("v%d.%d.%d", current.Major, current.Minor, current.Patch+1), nil
    }
    
    return "", fmt.Errorf("unknown bump type: %v", bumpType)
}

// internal/release/validator.go
type ReleaseValidator struct {
    checks []ReleaseCheck
}

func (rv *ReleaseValidator) RunPreReleaseChecks() error {
    for _, check := range rv.checks {
        if err := check.Run(); err != nil {
            return fmt.Errorf("check '%s' failed: %w", check.Name(), err)
        }
    }
    return nil
}

// Implement various checks
type TestsPassCheck struct{}
func (t *TestsPassCheck) Run() error {
    // Run go test ./...
    cmd := exec.Command("go", "test", "./...")
    if err := cmd.Run(); err != nil {
        return fmt.Errorf("tests failed")
    }
    return nil
}

type BuildCheck struct{}
func (b *BuildCheck) Run() error {
    // Verify build succeeds
    cmd := exec.Command("go", "build", "./...")
    return cmd.Run()
}

// cmd/release/main.go
package main

import (
    "github.com/spf13/cobra"
)

func main() {
    rootCmd := &cobra.Command{
        Use:   "release",
        Short: "Automated release preparation tool",
    }
    
    prepareCmd := &cobra.Command{
        Use:   "prepare [version]",
        Short: "Prepare a new release",
        RunE: func(cmd *cobra.Command, args []string) error {
            manager := release.NewManager()
            
            version := args[0]
            releaseType, _ := cmd.Flags().GetString("type")
            
            rel, err := manager.PrepareRelease(version, releaseType)
            if err != nil {
                return err
            }
            
            // Output release information
            fmt.Printf("Release %s prepared successfully\n", rel.Version)
            fmt.Printf("Changelog:\n%s\n", rel.Changelog.Format())
            
            return nil
        },
    }
    
    rootCmd.AddCommand(prepareCmd)
    rootCmd.Execute()
}

// .github/workflows/release-automation.yml
name: Automated Release Process
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
      release_type:
        description: 'Release type'
        type: choice
        options:
          - stable
          - beta
          - rc

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          
      - name: Run Release Preparation
        run: |
          go run cmd/release/main.go prepare ${{ github.event.inputs.version }} \
            --type ${{ github.event.inputs.release_type }}
            
      - name: Create Release PR
        uses: peter-evans/create-pull-request@v5
        with:
          title: "Release ${{ github.event.inputs.version }}"
          body: |
            Automated release preparation for version ${{ github.event.inputs.version }}
            
            ## Checklist
            - [ ] Tests passing
            - [ ] Changelog reviewed
            - [ ] Version bumped
            - [ ] Documentation updated
          branch: release/${{ github.event.inputs.version }}

// internal/release/templates/changelog.tmpl
# Changelog

## [{{ .Version }}] - {{ .Date.Format "2006-01-02" }}

{{ range $section, $entries := .Sections }}
### {{ $section }}
{{ range $entries }}
- {{ .Description }} ({{ .CommitHash }})
{{ end }}
{{ end }}

## Previous Releases
{{ .PreviousContent }}

// pkg/models/release.go
type Release struct {
    Version     string
    Type        ReleaseType
    Changelog   *Changelog
    Assets      []ReleaseAsset
    CreatedAt   time.Time
    PublishedAt *time.Time
}

type Changelog struct {
    Version  string
    Date     time.Time
    Sections map[string][]ChangeEntry
}

type ChangeEntry struct {
    Type        string // feat, fix, docs, etc.
    Scope       string
    Description string
    CommitHash  string
    Author      string
    Breaking    bool
}

# Test Strategy:
Comprehensive testing strategy for the release preparation system:

1. **Version Management Tests**:
   - Test semantic version parsing and validation
   - Verify version bumping logic (major, minor, patch)
   - Test pre-release version handling (beta, rc)
   - Validate version format compliance

2. **Changelog Generation Tests**:
   - Mock git repository with various commit patterns
   - Test conventional commit parsing (feat:, fix:, docs:, etc.)
   - Verify commit categorization and grouping
   - Test changelog formatting with different templates
   - Handle edge cases: first release, no commits, merge commits

3. **Pre-release Validation Tests**:
   - Mock successful and failing test runs
   - Verify build check execution
   - Test custom validation rules
   - Ensure proper error reporting and aggregation

4. **Integration Tests**:
   - Test complete release preparation flow
   - Verify file generation (CHANGELOG.md, VERSION)
   - Test git operations (tag creation, commit)
   - Validate GitHub Actions workflow execution

5. **CLI Tests**:
   - Test command parsing and validation
   - Verify output formatting
   - Test interactive mode prompts
   - Validate error handling and help text

6. **End-to-End Tests**:
   - Create test repository with sample commits
   - Run full release preparation
   - Verify all artifacts are created correctly
   - Test rollback on failure

# Subtasks:
## 1. Implement Version Validation and Management [done]
### Dependencies: None
### Description: Develop the version validation and management component to ensure correct version formats and calculate the next version based on the bump type.
### Details:
Create methods to validate version formats and determine the next version using semantic versioning rules.

## 2. Develop Pre-Release Validation Checks [done]
### Dependencies: None
### Description: Implement pre-release validation checks to ensure code quality and build integrity before proceeding with the release.
### Details:
Create checks such as running tests and verifying build success to ensure the codebase is ready for release.

## 3. Create Changelog Generation System [done]
### Dependencies: 18.1
### Description: Design and implement a system to generate changelogs from commit history, categorizing changes appropriately.
### Details:
Use commit history to generate a structured changelog, categorizing changes by type and scope.

## 4. Integrate Release Preparation Workflow [done]
### Dependencies: 18.1, 18.2, 18.3
### Description: Integrate all components into a cohesive release preparation workflow that automates the release process.
### Details:
Combine version management, validation checks, and changelog generation into a single automated workflow.

## 5. Implement Post-Release Notification System [done]
### Dependencies: 18.4
### Description: Develop a notification system to inform stakeholders of release completion and provide release details.
### Details:
Create a notification mechanism to send release details and changelogs to relevant stakeholders after release completion.

