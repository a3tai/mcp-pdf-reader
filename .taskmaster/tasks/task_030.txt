# Task ID: 30
# Title: Enhance Error Messaging and Configuration Validation
# Status: pending
# Dependencies: 2, 3, 4, 5, 9, 10, 27, 28
# Priority: medium
# Description: Implement comprehensive error message improvements and configuration parameter validation across all PDF extraction tools, providing clear, actionable guidance to users when errors occur and ensuring configuration parameters are properly validated and applied.
# Details:
Implement a robust error handling and configuration validation system that provides clear, actionable error messages and validates all configuration parameters:

```go
// internal/errors/user_errors.go
package errors

import (
    "fmt"
    "strings"
)

type UserError struct {
    Code      string
    Message   string
    Details   string
    Guidance  string
    Context   map[string]interface{}
}

func (e *UserError) Error() string {
    var sb strings.Builder
    sb.WriteString(fmt.Sprintf("Error %s: %s\n", e.Code, e.Message))
    if e.Details != "" {
        sb.WriteString(fmt.Sprintf("Details: %s\n", e.Details))
    }
    if e.Guidance != "" {
        sb.WriteString(fmt.Sprintf("How to fix: %s\n", e.Guidance))
    }
    if len(e.Context) > 0 {
        sb.WriteString("Context:\n")
        for k, v := range e.Context {
            sb.WriteString(fmt.Sprintf("  %s: %v\n", k, v))
        }
    }
    return sb.String()
}

// Common error constructors
func NoContentElementsError() *UserError {
    return &UserError{
        Code:    "PDF_NO_CONTENT",
        Message: "No content elements provided for extraction",
        Details: "The PDF document appears to be empty or contains no extractable content",
        Guidance: "Please ensure:\n" +
            "1. The PDF file is not corrupted\n" +
            "2. The PDF contains actual content (text, images, or forms)\n" +
            "3. The PDF is not password-protected\n" +
            "4. Try using --mode=complete for comprehensive extraction",
    }
}

func InvalidConfigurationError(param string, value interface{}, reason string) *UserError {
    return &UserError{
        Code:    "CONFIG_INVALID",
        Message: fmt.Sprintf("Invalid configuration parameter: %s", param),
        Details: reason,
        Context: map[string]interface{}{
            "parameter": param,
            "value":     value,
        },
        Guidance: getConfigGuidance(param),
    }
}

// internal/config/validator.go
package config

import (
    "github.com/yourusername/pdfextract/internal/errors"
)

type ConfigValidator struct {
    rules map[string]ValidationRule
}

type ValidationRule struct {
    Type        string
    Required    bool
    MinValue    interface{}
    MaxValue    interface{}
    ValidValues []interface{}
    Validator   func(interface{}) error
}

func NewConfigValidator() *ConfigValidator {
    return &ConfigValidator{
        rules: map[string]ValidationRule{
            "mode": {
                Type:        "string",
                Required:    false,
                ValidValues: []interface{}{"complete", "semantic", "structured"},
            },
            "page_range": {
                Type:      "string",
                Required:  false,
                Validator: validatePageRange,
            },
            "output_format": {
                Type:        "string",
                Required:    false,
                ValidValues: []interface{}{"json", "xml", "csv", "text"},
            },
            "chunk_size": {
                Type:     "int",
                Required: false,
                MinValue: 100,
                MaxValue: 10000,
            },
            "timeout": {
                Type:     "duration",
                Required: false,
                MinValue: "1s",
                MaxValue: "1h",
            },
        },
    }
}

func (cv *ConfigValidator) Validate(config map[string]interface{}) error {
    appliedParams := make([]string, 0)
    
    for param, value := range config {
        rule, exists := cv.rules[param]
        if !exists {
            return errors.InvalidConfigurationError(param, value, 
                fmt.Sprintf("Unknown parameter '%s'. Valid parameters are: %s", 
                    param, cv.getValidParams()))
        }
        
        if err := cv.validateParam(param, value, rule); err != nil {
            return err
        }
        
        appliedParams = append(appliedParams, param)
    }
    
    // Log applied configuration
    if len(appliedParams) > 0 {
        log.Info("Applied configuration parameters: %s", strings.Join(appliedParams, ", "))
    }
    
    return nil
}

// internal/pdf/extraction/error_context.go
package extraction

type ErrorContext struct {
    Operation   string
    PageNumber  int
    ElementType string
    Position    *BoundingBox
    Metadata    map[string]interface{}
}

func (ec *ErrorContext) WrapError(err error) error {
    if userErr, ok := err.(*errors.UserError); ok {
        // Enhance existing user error with context
        if userErr.Context == nil {
            userErr.Context = make(map[string]interface{})
        }
        userErr.Context["operation"] = ec.Operation
        if ec.PageNumber > 0 {
            userErr.Context["page"] = ec.PageNumber
        }
        if ec.ElementType != "" {
            userErr.Context["element_type"] = ec.ElementType
        }
        return userErr
    }
    
    // Convert technical errors to user-friendly errors
    return ec.convertToUserError(err)
}

// Update extraction tools to use enhanced error handling
// cmd/pdf_extract_text/main.go
func main() {
    // ... existing code ...
    
    // Validate configuration early
    validator := config.NewConfigValidator()
    if err := validator.Validate(extractConfig); err != nil {
        fmt.Fprintf(os.Stderr, "%v\n", err)
        os.Exit(1)
    }
    
    // Enhanced error handling during extraction
    result, err := extractor.Extract(doc)
    if err != nil {
        if result != nil && result.ElementCount == 0 {
            err = errors.NoContentElementsError()
        }
        
        // Add file context to error
        if userErr, ok := err.(*errors.UserError); ok {
            userErr.Context["file"] = inputFile
            userErr.Context["file_size"] = getFileSize(inputFile)
        }
        
        fmt.Fprintf(os.Stderr, "%v\n", err)
        os.Exit(1)
    }
}

// internal/cli/help.go
package cli

type ParameterHelp struct {
    Name        string
    Type        string
    Default     string
    Description string
    Examples    []string
}

func GetParameterHelp() []ParameterHelp {
    return []ParameterHelp{
        {
            Name:        "mode",
            Type:        "string",
            Default:     "complete",
            Description: "Extraction mode determining what content to extract",
            Examples: []string{
                "--mode=complete  # Extract all content types",
                "--mode=semantic  # Extract with semantic structure",
                "--mode=structured  # Extract with full document structure",
            },
        },
        {
            Name:        "page_range",
            Type:        "string",
            Default:     "all",
            Description: "Pages to extract (1-based indexing)",
            Examples: []string{
                "--page_range=1-10  # First 10 pages",
                "--page_range=5     # Only page 5",
                "--page_range=1,3,5-7  # Pages 1, 3, 5, 6, and 7",
            },
        },
        // ... more parameters
    }
}

# Test Strategy:
Comprehensive testing strategy for error messaging and configuration validation:

1. **Error Message Clarity Tests**:
   - Test "no content elements" error with empty PDFs, image-only PDFs, and corrupted files
   - Verify error messages include specific guidance for each scenario
   - Test that file context (name, size) is included in error output
   - Verify error codes are consistent and documented

2. **Configuration Validation Tests**:
   - Test each configuration parameter with valid and invalid values
   - Verify unknown parameters are rejected with list of valid options
   - Test boundary values (min/max for numeric parameters)
   - Verify type validation (string vs int vs duration)
   - Test that valid configurations log "Applied configuration parameters" message

3. **Integration Tests**:
   - Test all extraction tools (text, forms, images, structured) with invalid configs
   - Verify consistent error format across all tools
   - Test parameter combinations that might conflict
   - Verify --help displays all parameters with examples

4. **User Experience Tests**:
   - Have users unfamiliar with the tool attempt common tasks
   - Document confusing error messages they encounter
   - Test error messages in different terminal environments
   - Verify guidance is actionable and resolves the issue

5. **Regression Tests**:
   - Create test suite with previously confusing errors
   - Ensure "no content elements provided" includes proper guidance
   - Test that configuration parameters are actually applied (not just validated)
   - Verify error context includes relevant debugging information
